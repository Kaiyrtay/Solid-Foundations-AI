(Level 1 - Claude AI)
The Task — All 5 SOLID Principles, One System

What you're building:
A console-based Library Management System:
frontend.py — wiring + console interaction.
backend.py — all logic, zero console.

What it must do:

Add a book (title, author, year)
Remove a book
Save and load books from a file
Show a report of all books
Support multiple notification types when a book is added (email, SMS — console fakes are fine)
Support multiple storage types (JSON file, CSV file)


Where each principle lives:
S — Every class has one job. Book data, file saving, report generation, notifications — all separate.
O — Adding a new storage type (CSV) or new notification type (Slack) requires zero edits to existing classes.
L — Any storage class can replace another without breaking anything. Any notifier can replace another without breaking anything.
I — No class is forced to implement methods it doesn't need. Split your interfaces smart.
D — Backend classes never hardcode their dependencies. Everything gets injected in.

You pass when:

backend.py has zero print() or input()
frontend.py has zero business logic
I can swap JSON storage for CSV storage with one line change
I can add a new notifier without touching existing code
Every class has exactly one reason to change

Level 2 — Same Rules, Harder Fight

What you're building:
A console-based Student Grade Management System. Backend and frontend. Same rules — zero print() in backend, zero logic in frontend.

What it must do:

Add a student (name, student ID)
Add a grade for a student (subject, score)
Calculate average grade per student
Pass or fail a student based on average (passing score = 60)
Generate a full report of all students and their grades
Export report to JSON and TXT file
Send notification when a student fails


Where it gets harder than Level 1:

A Student holds grades. A Grade is its own class. They are not the same thing — don't mix them.
GradeCalculator is a separate class. Student does not calculate its own average — that violates S.
PassFailEvaluator is a separate class. GradeCalculator does not decide pass or fail — that's a different job.
Exporting to JSON and TXT must be swappable without touching anything else — O principle, same as Level 1 but you know what happens if you get it wrong.
ReportGenerator takes students and produces a string. Nothing else.
NotificationService same pattern as Level 1 — abstract, injectable.


You pass when:

I can swap TXT export for JSON export in one line
Student class has zero calculation logic
Adding a new evaluator rule (e.g. pass score = 70) requires zero edits to existing classes
Backend has zero print() or input()
Frontend has zero logic